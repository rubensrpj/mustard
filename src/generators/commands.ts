import type { ProjectInfo, GeneratedCommands } from '../types.js';
import { getRunCommand, getInstallCommand } from '../services/package-manager.js';

/**
 * Mustard commands subfolder
 * Commands generated by Mustard go in commands/mustard/
 * User-created commands go directly in commands/
 */
export const MUSTARD_COMMANDS_FOLDER = 'mustard';

/**
 * Generate command files
 * All generated commands go in the mustard/ subfolder
 */
export function generateCommands(projectInfo: ProjectInfo): GeneratedCommands {
  const commands: GeneratedCommands = {
    // Pipeline commands
    'feature': generatePipelineFeatureCommand(projectInfo),
    'bugfix': generatePipelineBugfixCommand(projectInfo),
    'approve': generatePipelineApproveCommand(),
    'complete': generatePipelineCompleteCommand(),
    'resume': generatePipelineResumeCommand(),

    // Git commands
    'commit': generateGitCommitCommand(),
    'commit-push': generateGitPushCommand(),
    'merge-main': generateGitMergeCommand(),

    // Validate commands
    'validate': generateValidateBuildCommand(projectInfo),
    'status': generateValidateStatusCommand(projectInfo),

    // Sync commands
    'sync-registry': generateSyncRegistryCommand(),
    'install-deps': generateSyncDependenciesCommand(projectInfo),
    'sync-context': generateSyncContextCommand(),

    // Report commands
    'report-daily': generateReportDailyCommand(),
    'report-weekly': generateReportWeeklyCommand(),

    // Scan commands
    'scan': generateScanProjectCommand(),

    // Task commands (L0 Universal Delegation)
    'task-analyze': generateTaskAnalyzeCommand(),
    'task-review': generateTaskReviewCommand(),
    'task-refactor': generateTaskRefactorCommand(),
    'task-docs': generateTaskDocsCommand()
  };

  return commands;
}

// ============== Pipeline Commands ==============

function generatePipelineFeatureCommand(projectInfo: ProjectInfo): string {
  return `# /feature - Feature Pipeline

## Trigger

\`/feature <feature-name>\`

## Description

Starts the full pipeline to implement a new feature.

## Flow

1. **EXPLORE**
   - Use Task(Explore) to analyze requirements
   - Map related existing files
   - Identify patterns to follow

2. **SPEC**
   - Create spec at \`spec/active/{name}/spec.md\`
   - List files to create/modify
   - Define implementation checklist

3. **APPROVE**
   - Present spec to user
   - Wait for /approve or feedback

4. **IMPLEMENT**
   - Delegate to specialized agents
   - Backend â†’ Frontend â†’ Database (order as needed)

5. **REVIEW**
   - Validate implementation
   - Verify checklist

6. **COMPLETE**
   - Update entity-registry if needed
   - Move spec to completed/

## Example

\`\`\`
User: /feature add-partner-email-field

Claude:
1. Explores codebase to understand Partner
2. Creates spec with implementation plan
3. Presents spec for approval
4. (after /approve) Implements Database â†’ Backend â†’ Frontend
5. Validates and completes
\`\`\`
`;
}

function generatePipelineBugfixCommand(projectInfo: ProjectInfo): string {
  return `# /bugfix - Bug Fix Pipeline

## Trigger

\`/bugfix <error-description>\`

## Description

Starts the pipeline to diagnose and fix a bug.

## Flow

1. **DIAGNOSE**
   - Use grepai to search related code
   - Identify root cause
   - Document findings

2. **SPEC**
   - Create spec at \`spec/active/{name}/spec.md\`
   - Describe root cause
   - Propose fix

3. **APPROVE**
   - Present diagnosis to user
   - Wait for /approve

4. **FIX**
   - Apply minimal fix
   - Do not make unrelated changes

5. **VALIDATE**
   - Verify bug is fixed
   - Verify nothing broke

6. **COMPLETE**
   - Document solution
   - Move spec to completed/

## Example

\`\`\`
User: /bugfix error saving contract

Claude:
1. Uses grepai to find save code
2. Identifies root cause
3. Presents diagnosis
4. (after /approve) Fixes
5. Validates and completes
\`\`\`
`;
}

function generatePipelineApproveCommand(): string {
  return `# /approve - Approve Spec

## Trigger

\`/approve\`

## Description

Approves the current spec and enables the implementation phase.

## Prerequisites

- Active pipeline (created via /feature or /bugfix)
- Spec presented awaiting approval

## Action

1. Marks pipeline as "approved"
2. Enables implementation start
3. Claude proceeds automatically

## Alternative Flow

If the spec is not satisfactory, the user can:
- Give text feedback for adjustments
- Use /complete to cancel

\`\`\`
User: /approve

Claude: âœ… Spec approved! Starting implementation...
\`\`\`
`;
}

function generatePipelineCompleteCommand(): string {
  return `# /complete - Finalize Pipeline

## Trigger

\`/complete\`

## Description

Finalizes the current pipeline, either completing or canceling.

## Action

1. Moves spec from \`spec/active/\` to \`spec/completed/\`
2. Updates entity-registry if needed
3. Clears pipeline state

## When to Use

- After successful implementation and review
- To cancel an ongoing pipeline
- To force close if something went wrong

\`\`\`
User: /complete

Claude: âœ… Pipeline finalized!
        Spec moved to spec/completed/{name}/
        Entity registry updated.
\`\`\`
`;
}

function generatePipelineResumeCommand(): string {
  return `# /resume - Resume Pipeline

## Trigger

\`/resume\`

## Description

Resumes a pipeline that was interrupted.

## Action

1. Finds active pipeline
2. Identifies last completed phase
3. Continues from where it stopped

## When to Use

- After restarting Claude session
- After accidental interruption
- To continue work from another session

\`\`\`
User: /resume

Claude: ðŸ”„ Resuming pipeline "add-email-partner"
        Last phase: IMPLEMENT
        Continuing with Backend...
\`\`\`
`;
}

// ============== Git Commands ==============

function generateGitCommitCommand(): string {
  return `# /commit - Simple Commit

## Trigger

\`/commit\`

## Description

Creates a commit with current changes.

## Action

1. Runs \`git status\` to see changes
2. Runs \`git diff\` to analyze content
3. Generates commit message based on changes
4. Runs \`git add\` + \`git commit\`

## Message Format

\`\`\`
<type>: <short description>

<detailed description if needed>

Co-Authored-By: Claude <noreply@anthropic.com>
\`\`\`

Types: feat, fix, refactor, docs, chore, test
`;
}

function generateGitPushCommand(): string {
  return `# /commit-push - Commit and Push

## Trigger

\`/commit-push\`

## Description

Creates commit and pushes to remote.

## Action

1. Same process as /commit
2. Adds \`git push\` at the end

## Cautions

- Checks if branch has remote configured
- Uses \`git push -u origin <branch>\` if needed
`;
}

function generateGitMergeCommand(): string {
  return `# /merge-main - Merge to Main

## Trigger

\`/merge-main\`

## Description

Merges current branch to main/master.

## Action

1. Checks for uncommitted changes
2. Switches to main branch
3. Pulls latest changes
4. Merges feature branch
5. Pushes to remote

## Cautions

- Will abort if there are merge conflicts
- Requires clean working directory
`;
}

// ============== Validate Commands ==============

function generateValidateBuildCommand(projectInfo: ProjectInfo): string {
  const hasNode = projectInfo.stacks.some(s => ['react', 'nextjs', 'node'].includes(s.name));
  const hasDotnet = projectInfo.stacks.some(s => s.name === 'dotnet');
  const pm = projectInfo.packageManager ?? 'npm';

  const steps: string[] = [];

  if (hasDotnet) {
    steps.push('- `dotnet build` - Verifies .NET compiles');
  }

  if (hasNode) {
    steps.push(`- \`${getRunCommand(pm, 'typecheck')}\` - Verifies TypeScript types`);
    steps.push(`- \`${getRunCommand(pm, 'lint')}\` - Verifies linting (if available)`);
  }

  return `# /validate - Build Validation

## Trigger

\`/validate\`

## Description

Runs build and type-check validations.

## Actions

${steps.join('\n') || '- Verify project compilation'}

## Result

- âœ… **Success** - Project compiles and passes type-check
- âŒ **Failure** - Lists errors found
`;
}

function generateValidateStatusCommand(projectInfo: ProjectInfo): string {
  return `# /status - Consolidated Status

## Trigger

\`/status\`

## Description

Shows consolidated project status.

## Information

1. **Git Status**
   - Current branch
   - Modified files
   - Commits pending push

2. **Pipeline**
   - Active pipeline (if any)
   - Current phase

3. **Build**
   - Last validation result

4. **Entity Registry**
   - Number of entities
   - Last update
`;
}

// ============== Sync Commands ==============

function generateSyncRegistryCommand(): string {
  return `# /sync-registry - Update Entity Registry

## Trigger

\`/sync-registry\`

## Description

Scans the project and updates entity-registry.json.

## Action

1. Searches database schemas (Drizzle, Prisma, etc)
2. Searches backend entities (.NET, Node, etc)
3. Updates \`.claude/entity-registry.json\`

## When to Use

- After creating new entity
- After importing existing code
- To sync after manual changes
`;
}

function generateSyncDependenciesCommand(projectInfo: ProjectInfo): string {
  const pm = projectInfo.packageManager ?? 'npm';
  const hasDotnet = projectInfo.stacks.some(s => s.name === 'dotnet');

  return `# /install-deps - Install Dependencies

## Trigger

\`/install-deps\`

## Description

Installs dependencies for all projects.

## Actions

${hasDotnet ? '- `dotnet restore` - Restores NuGet packages\n' : ''}- \`${getInstallCommand(pm)}\` - Installs Node dependencies

## Subprojects

If monorepo, runs in all configured subprojects.
`;
}

function generateSyncContextCommand(): string {
  return `# /sync-context - Load Project Context

## Trigger

\`/sync-context\`
\`/sync-context --refresh\`

## Description

Discovers and caches project context for faster implementations.

## What It Does

1. Reads \`.claude/context/*.md\` for user-provided context
2. Reads \`.claude/CLAUDE.md\` for project rules and conventions
3. Reads \`.claude/entity-registry.json\` for entity mappings
4. Uses grepai to discover code patterns (services, repos, components)
5. Stores all in memory MCP as entities

## When It Runs

- **Automatically** at the start of /feature or /bugfix (if context is missing or stale)
- **Manually** when you run /sync-context
- **Force refresh** with /sync-context --refresh

## Context Sources

| Source | Entity Type | Content |
|--------|-------------|---------|
| \`.claude/context/*.md\` | \`UserContext:*\` | User-provided specs, tips, examples |
| \`.claude/CLAUDE.md\` | \`ProjectContext\` | Stacks, naming, conventions |
| \`.claude/entity-registry.json\` | \`EntityRegistry\` | Entity mappings |
| \`.claude/core/enforcement.md\` | \`EnforcementRules\` | L0-L9 rules |
| grepai discovery | \`CodePattern:*\` | Services, repos, components |

## Output

\`\`\`
âœ… Context loaded successfully

Project Context:
- Type: monorepo
- Stacks: dotnet:9.0, react:19.x

User Context (3 files):
- architecture.md
- business-rules.md
- tips.md

Code Patterns:
- service (Backend/Services/ContractService.cs)
- repository (Backend/Repositories/ContractRepository.cs)
\`\`\`

## Context Refresh Strategy

| Trigger | Action |
|---------|--------|
| Context > 24h old | Auto-refresh on /feature or /bugfix |
| \`/sync-context --refresh\` | Force full refresh |
| \`/sync-registry\` | Refresh only EntityRegistry |

## See Also

- [context/README.md](../context/README.md) - How to create context files
- [/feature](./feature.md) - Feature pipeline (auto-loads context)
- [/bugfix](./bugfix.md) - Bugfix pipeline (auto-loads context)
`;
}

// ============== Report Commands ==============

function generateReportDailyCommand(): string {
  return `# /report-daily - Daily Report

## Trigger

\`/report-daily\`

## Description

Generates a daily progress report.

## Content

1. **Commits Today**
   - List of commits made
   - Files changed

2. **Pipeline Activity**
   - Features started/completed
   - Bugs fixed

3. **Pending Items**
   - Open pipelines
   - Uncommitted changes

## Output Format

Markdown report suitable for sharing or documentation.
`;
}

function generateReportWeeklyCommand(): string {
  return `# /report-weekly - Weekly Report

## Trigger

\`/report-weekly\`

## Description

Generates a weekly progress report.

## Content

1. **Week Summary**
   - Total commits
   - Features completed
   - Bugs fixed

2. **Entity Changes**
   - New entities created
   - Entities modified

3. **Code Metrics**
   - Lines added/removed
   - Files changed

## Output Format

Markdown report suitable for team updates.
`;
}

// ============== Scan Commands ==============

function generateScanProjectCommand(): string {
  return `# /scan - Scan Project

## Trigger

\`/scan\`

## Description

Scans the project structure and updates detection.

## Action

1. Detects technology stacks
2. Maps folder structure
3. Identifies naming conventions
4. Updates project state

## When to Use

- After major structural changes
- When adding new technology
- To refresh project detection
`;
}

// ============== Task Commands (L0 Universal Delegation) ==============

function generateTaskAnalyzeCommand(): string {
  return `# /task-analyze - Code Analysis

> Analyzes code in a **separate Task context** (L0 Universal Delegation).

## Trigger

\`/task-analyze <scope>\`

## Description

Analyzes code in a separate Task(Explore) context.
Use for any code exploration that doesn't fit feature/bugfix pipelines.

## L0 Enforcement

**CRITICAL**: This command enforces L0 Universal Delegation:
- Parent context does NOT read code
- Parent context ONLY coordinates and presents results
- ALL analysis happens in Task(Explore) context

## Flow

1. **DELEGATE** ðŸ”
   - Create Task(Explore) with analysis scope
   - Never analyze directly in parent context

2. **REPORT**
   - Present findings to user

## Implementation

\`\`\`javascript
Task({
  subagent_type: "Explore",
  model: "haiku",
  description: \`ðŸ” Analyze: \${scope}\`,
  prompt: \`
    # ðŸ” CODE ANALYSIS TASK
    ## Scope: \${scope}
    ## Instructions
    1. Use grepai_search for semantic search
    2. Read relevant files
    3. Document patterns found
    4. Report findings clearly
  \`
})
\`\`\`

## Examples

\`\`\`bash
/task-analyze authentication flow
/task-analyze "database schema"
/task-analyze error handling patterns
\`\`\`
`;
}

function generateTaskReviewCommand(): string {
  return `# /task-review - Code Review

> Performs code review in a **separate Task context** (L0 Universal Delegation).

## Trigger

\`/task-review <scope>\`

## Description

Reviews code quality in a separate Task(general-purpose) context.
Use for QA, SOLID validation, security checks.

## L0 Enforcement

**CRITICAL**: This command enforces L0 Universal Delegation:
- Parent context does NOT read code
- Parent context ONLY coordinates and presents results
- ALL review happens in Task(general-purpose) context

## Flow

1. **DELEGATE** ðŸ”Ž
   - Create Task(general-purpose) with review prompt
   - Never review directly in parent context

2. **REPORT**
   - Present findings with severity levels

## Implementation

\`\`\`javascript
Task({
  subagent_type: "general-purpose",
  model: "opus",
  description: \`ðŸ”Ž Review: \${scope}\`,
  prompt: \`
    # ðŸ”Ž CODE REVIEW TASK
    ## Scope: \${scope}
    ## Checklist
    - [ ] SOLID principles
    - [ ] Error handling
    - [ ] Security concerns
    - [ ] Performance issues
    ## Output: [Severity] File:Line - Issue - Suggestion
  \`
})
\`\`\`

## Examples

\`\`\`bash
/task-review src/services/payment
/task-review "Contract entity"
/task-review "security in auth module"
\`\`\`
`;
}

function generateTaskRefactorCommand(): string {
  return `# /task-refactor - Code Refactoring

> Refactors code in **separate Task contexts** (L0 Universal Delegation).

## Trigger

\`/task-refactor <scope>\`

## Description

Refactors code using Plan â†’ Approve â†’ Implement flow.
Uses separate Task contexts for planning and execution.

## L0 Enforcement

**CRITICAL**: This command enforces L0 Universal Delegation:
- Parent context does NOT read code
- Parent context does NOT plan or implement
- ALL work happens in Task(Plan) and Task(general-purpose) contexts

## Flow

1. **PLAN** ðŸ“‹
   - Create Task(Plan) to analyze scope
   - Propose refactoring strategy

2. **APPROVE**
   - Present plan to user
   - Wait for approval

3. **IMPLEMENT** âš™ï¸
   - Create Task(general-purpose) to execute
   - Apply changes incrementally

4. **VALIDATE**
   - Run build/tests

## Implementation

\`\`\`javascript
// Phase 1: Plan
Task({
  subagent_type: "Plan",
  model: "sonnet",
  description: \`ðŸ“‹ Plan refactor: \${scope}\`,
  prompt: \`# Plan refactoring for \${scope}...\`
})

// Phase 2: Execute (after approval)
Task({
  subagent_type: "general-purpose",
  model: "opus",
  description: \`âš™ï¸ Execute refactor: \${scope}\`,
  prompt: \`# Execute approved plan...\`
})
\`\`\`

## Examples

\`\`\`bash
/task-refactor "extract PaymentService"
/task-refactor "rename User to Account"
/task-refactor "split large component"
\`\`\`
`;
}

function generateTaskDocsCommand(): string {
  return `# /task-docs - Documentation Generation

> Generates documentation in a **separate Task context** (L0 Universal Delegation).

## Trigger

\`/task-docs <scope>\`

## Description

Generates documentation in a separate Task(general-purpose) context.
Use for API docs, README updates, or technical documentation.

## L0 Enforcement

**CRITICAL**: This command enforces L0 Universal Delegation:
- Parent context does NOT read code
- Parent context does NOT generate documentation
- ALL work happens in Task(general-purpose) context

## Flow

1. **DELEGATE** ðŸ“Š
   - Create Task(general-purpose) with docs prompt
   - Never generate docs in parent context

2. **PRESENT**
   - Show generated documentation
   - Ask for approval before saving

## Implementation

\`\`\`javascript
Task({
  subagent_type: "general-purpose",
  model: "sonnet",
  description: \`ðŸ“Š Docs: \${scope}\`,
  prompt: \`
    # ðŸ“Š DOCUMENTATION TASK
    ## Scope: \${scope}
    ## Instructions
    1. Use grepai to find relevant code
    2. Generate appropriate documentation
    3. Indicate where to save
  \`
})
\`\`\`

## Examples

\`\`\`bash
/task-docs "API endpoints"
/task-docs "Contract entity"
/task-docs "update README"
\`\`\`
`;
}
